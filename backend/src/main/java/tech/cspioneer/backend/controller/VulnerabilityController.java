package tech.cspioneer.backend.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import org.springframework.web.bind.annotation.*;
import tech.cspioneer.backend.common.ApiResponse;
import tech.cspioneer.backend.entity.VulnerabilityMetadata;
import tech.cspioneer.backend.entity.User;
import tech.cspioneer.backend.entity.VulnerabilityProject;
import tech.cspioneer.backend.service.VulnerabilityService;
import tech.cspioneer.backend.mapper.TagMapper;
import tech.cspioneer.backend.mapper.CategoryMapper;
import tech.cspioneer.backend.mapper.VulnerabilityAffectedPackageMapper;
import tech.cspioneer.backend.search.SearchFacade;

import java.security.Principal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/vulns")
@Tag(name = "漏洞管理（表单方式）")
@SecurityRequirement(name = "bearerAuth")
public class VulnerabilityController {
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityController.class);
    private final VulnerabilityService service;
    private final TagMapper tagMapper;
    private final CategoryMapper categoryMapper;
    private final VulnerabilityAffectedPackageMapper affectedPackageMapper;
    private final SearchFacade searchFacade;
    private final tech.cspioneer.backend.mapper.UserMapper userMapper;
    private final tech.cspioneer.backend.mapper.LnkUserOrganizationMapper lnkUserOrganizationMapper;

    public VulnerabilityController(VulnerabilityService service, TagMapper tagMapper, CategoryMapper categoryMapper, SearchFacade searchFacade,
                                  tech.cspioneer.backend.mapper.UserMapper userMapper,
                                  tech.cspioneer.backend.mapper.LnkUserOrganizationMapper lnkUserOrganizationMapper,
                                  VulnerabilityAffectedPackageMapper affectedPackageMapper) {
        this.service = service;
        this.tagMapper = tagMapper;
        this.categoryMapper = categoryMapper;
        this.searchFacade = searchFacade;
        this.userMapper = userMapper;
        this.lnkUserOrganizationMapper = lnkUserOrganizationMapper;
        this.affectedPackageMapper = affectedPackageMapper;
    }

    public static class CreateReq {
        public String organizationUuid;
        @NotBlank public String summary;
        @NotBlank public String details;
        @NotNull public Float severityNum;
        @NotBlank public String language;
        public String categoryCode;
        @io.swagger.v3.oas.annotations.media.Schema(description = "标签名称（兼容，已弃用）", deprecated = true)
        public List<String> tags;      // 兼容：按名称传入（弃用）
        @io.swagger.v3.oas.annotations.media.Schema(description = "标签代码（推荐）")
        public List<String> tagCodes;  // 新字段：按 code 传入
        public List<ProjectReq> projects;
        @io.swagger.v3.oas.annotations.media.Schema(description = "可选：完整COSV负载（导入时可一并提交）")
        public tech.cspioneer.backend.dto.CosvUpsert cosv;
    }
    public static class ProjectReq {
        @NotBlank public String name;
        public String url;
        public String versions;
        public String type;
    }

    @PostMapping
    @Operation(summary = "创建漏洞（表单方式）")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Map<String, Object>> create(@Valid @RequestBody CreateReq req, Principal principal) {
        List<VulnerabilityProject> projects = null;
        if (req.projects != null) {
            projects = req.projects.stream().map(pr -> {
                VulnerabilityProject p = new VulnerabilityProject();
                p.setName(pr.name); p.setUrl(pr.url); p.setVersions(pr.versions); p.setType(pr.type);
                return p;
            }).toList();
        }
        List<String> tagKeys = (req.tagCodes != null && !req.tagCodes.isEmpty()) ? req.tagCodes : req.tags;
        VulnerabilityMetadata vm = service.create(principal.getName(), req.organizationUuid, req.summary, req.details, req.severityNum, req.language, req.categoryCode, tagKeys, projects, req.cosv);
        Map<String, Object> data = new HashMap<>();
        data.put("vulnerability", vmView(vm));
        data.put("cosv", service.buildCosvView(vm));
        return ApiResponse.success(data);
    }

    

    @GetMapping
    @Operation(summary = "漏洞分页列表（支持过滤）")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:read')")
    public ApiResponse<Map<String, Object>> list(@RequestParam(value = "language", required = false) String language,
                                                 @RequestParam(value = "status", required = false) String status,
                                                 @RequestParam(value = "identifierPrefix", required = false) String identifierPrefix,
                                                 @Parameter(description = "标签名称（兼容，已弃用）", deprecated = true) @RequestParam(value = "tag", required = false) String tag,
                                                 @Parameter(description = "标签代码（推荐）") @RequestParam(value = "tagCode", required = false) String tagCode,
                                                 @RequestParam(value = "organizationUuid", required = false) String organizationUuid,
                                                 @RequestParam(value = "mine", required = false) Boolean mine,
                                                 @RequestParam(value = "category", required = false) String category,
                                                 @RequestParam(value = "submittedFrom", required = false) String submittedFrom,
                                                 @RequestParam(value = "submittedTo", required = false) String submittedTo,
                                                 @RequestParam(value = "modifiedFrom", required = false) String modifiedFrom,
                                                 @RequestParam(value = "modifiedTo", required = false) String modifiedTo,
                                                 @RequestParam(value = "sortBy", required = false) String sortBy,
                                                 @RequestParam(value = "sortOrder", required = false) String sortOrder,
                                                 @RequestParam(value = "page", required = false, defaultValue = "1") int page,
                                                 @RequestParam(value = "size", required = false, defaultValue = "20") int size,
                                                 @RequestParam(value = "withTotal", required = false, defaultValue = "false") boolean withTotal) {
        var items = service.list(
                language, status, identifierPrefix,
                null, // q（简单列表不支持全文检索）
                null, // languagesCSV（简单列表不支持多语言聚合过滤）
                null, // severityLevelsCSV
                null, // severityGe
                null, // severityLe
                tag, // tagName（兼容项）
                tagCode, // tagCode
                mine,
                organizationUuid,
                category,
                submittedFrom, submittedTo, modifiedFrom, modifiedTo,
                sortBy, sortOrder,
                page, size);
        Map<String, Object> data = new HashMap<>();
        data.put("page", page);
        data.put("size", size);
        data.put("items", items.stream().map(this::vmView).toList());
        if (withTotal) {
            long total = service.count(
                    language, status, identifierPrefix,
                    null, // q
                    null, // languagesCSV
                    null, // severityLevelsCSV
                    null, // severityGe
                    null, // severityLe
                    tag, // tagName
                    tagCode, // tagCode
                    mine,
                    organizationUuid,
                    category,
                    submittedFrom, submittedTo, modifiedFrom, modifiedTo);
            data.put("total", total);
        }
        return ApiResponse.success(data);
    }

    

    @GetMapping("/search")
    @Operation(summary = "漏洞分页列表（高级过滤：多语言/严重度）")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:read')")
    public ApiResponse<Map<String, Object>> search(@RequestParam(value = "languages", required = false) String languages,
                                                   @RequestParam(value = "severityLevels", required = false) String severityLevels,
                                                   @RequestParam(value = "severityGe", required = false) Float severityGe,
                                                   @RequestParam(value = "severityLe", required = false) Float severityLe,
                                                   @RequestParam(value = "status", required = false) String status,
                                                   @RequestParam(value = "q", required = false) String q,
                                                   @RequestParam(value = "identifierPrefix", required = false) String identifierPrefix,
                                                   @RequestParam(value = "organizationUuid", required = false) String organizationUuid,
                                                   @RequestParam(value = "mine", required = false) Boolean mine,
                                                   @RequestParam(value = "category", required = false) String category,
                                                   @RequestParam(value = "page", required = false, defaultValue = "1") int page,
                                                   @RequestParam(value = "size", required = false, defaultValue = "20") int size,
                                                   @RequestParam(value = "withTotal", required = false, defaultValue = "false") boolean withTotal,
                                                   @RequestParam(value = "sortBy", required = false, defaultValue = "modified") String sortBy,
                                                   @RequestParam(value = "sortOrder", required = false, defaultValue = "desc") String sortOrder) {
        if (log.isInfoEnabled()) {
            log.info("/vulns/search params q='{}' identifierPrefix='{}' languages='{}' severityLevels='{}' status='{}' page={} size={} sortBy={} sortOrder={} org={} category={}",
                    q, identifierPrefix, languages, severityLevels, status, page, size, sortBy, sortOrder, organizationUuid, category);
        }
        Map<String, Object> data = new HashMap<>();
        data.put("page", page);
        data.put("size", size);
        if (searchFacade != null && searchFacade.isEsEnabled() && (mine == null || !mine)) {
            var res = searchFacade.search(languages, severityLevels, severityGe, severityLe, status, q, identifierPrefix, organizationUuid, category, page, size, sortBy, sortOrder, withTotal);
            data.put("items", res.items());
            if (withTotal) data.put("total", res.total());
            return ApiResponse.success(data);
        } else {
            List<VulnerabilityMetadata> items = service.list(null, status, identifierPrefix, q, languages, severityLevels, severityGe, severityLe, null, null, mine, organizationUuid, category, null, null, null, null, sortBy, sortOrder, page, size);
            data.put("items", items.stream().map(this::vmView).toList());
            if (withTotal) {
                long total = service.count(null, status, identifierPrefix, q, languages, severityLevels, severityGe, severityLe, null, null, mine, organizationUuid, category, null, null, null, null);
                data.put("total", total);
            }
            return ApiResponse.success(data);
        }
    }

    @GetMapping("/{uuid}")
    @Operation(summary = "漏洞详情")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:read')")
    public ApiResponse<Map<String, Object>> get(@PathVariable("uuid") String uuid) {
        VulnerabilityMetadata vm = service.getByUuid(uuid);
        Map<String, Object> data = new HashMap<>();
        data.put("vulnerability", vmView(vm));
        data.put("cosv", service.buildCosvView(vm));
        return ApiResponse.success(data);
    }

    public static class UpdateReq {
        public String summary;
        public String details;
        public Float severityNum;
        public String language;
        public String status;
        public String categoryCode;
        @io.swagger.v3.oas.annotations.media.Schema(description = "可选：COSV增量（仅提供的子结构会替换原有值；未提供的不变）")
        public tech.cspioneer.backend.dto.CosvUpsert cosv;
    }

    @PatchMapping("/{uuid}")
    @Operation(summary = "更新漏洞（创建者或组织管理员）")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Map<String, Object>> update(@PathVariable("uuid") String uuid,
                                                   @Valid @RequestBody UpdateReq req,
                                                   Principal principal) {
        VulnerabilityMetadata vm = service.update(principal.getName(), uuid, req.summary, req.details, req.severityNum, req.language, req.status, req.categoryCode, req.cosv);
        Map<String, Object> data = new HashMap<>();
        data.put("vulnerability", vmView(vm));
        data.put("cosv", service.buildCosvView(vm));
        return ApiResponse.success(data);
    }

    public static class TagReq {
        @io.swagger.v3.oas.annotations.media.Schema(description = "标签代码（推荐）")
        public String code; // 优先
        @io.swagger.v3.oas.annotations.media.Schema(description = "标签名称（兼容，已弃用）", deprecated = true)
        public String name; // 兼容
    }

    @PostMapping("/{uuid}/tags")
    @Operation(summary = "添加标签")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Void> addTag(@PathVariable("uuid") String uuid,
                                    @Valid @RequestBody TagReq req,
                                    Principal principal) {
        String key = (req.code != null && !req.code.isBlank()) ? req.code : req.name;
        if (key == null || key.isBlank()) return ApiResponse.error(400, "标签不能为空");
        service.addTag(principal.getName(), uuid, key);
        return ApiResponse.success(null);
    }

    @DeleteMapping("/{uuid}/tags/{name}")
    @Operation(summary = "移除标签（路径参数可为code或name，name兼容且已弃用）")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Void> removeTag(@PathVariable("uuid") String uuid,
                                       @PathVariable("name") String name,
                                       Principal principal) {
        service.removeTag(principal.getName(), uuid, name);
        return ApiResponse.success(null);
    }

    @PostMapping("/{uuid}/projects")
    @Operation(summary = "添加相关项目")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Map<String, Object>> addProject(@PathVariable("uuid") String uuid,
                                                       @Valid @RequestBody ProjectReq req,
                                                       Principal principal) {
        VulnerabilityProject p = new VulnerabilityProject();
        p.setName(req.name); p.setUrl(req.url); p.setVersions(req.versions); p.setType(req.type);
        var saved = service.addProject(principal.getName(), uuid, p);
        Map<String, Object> data = new HashMap<>();
        data.put("project", saved);
        return ApiResponse.success(data);
    }

    @DeleteMapping("/{uuid}/projects/{projectUuid}")
    @Operation(summary = "移除相关项目")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Void> removeProject(@PathVariable("uuid") String uuid,
                                           @PathVariable("projectUuid") String projectUuid,
                                           Principal principal) {
        service.removeProject(principal.getName(), uuid, projectUuid);
        return ApiResponse.success(null);
    }

    private Map<String, Object> vmView(VulnerabilityMetadata vm) {
        Map<String, Object> m = new HashMap<>();
        m.put("uuid", vm.getUuid());
        m.put("identifier", vm.getIdentifier());
        m.put("summary", vm.getSummary());
        m.put("details", vm.getDetails());
        m.put("severityNum", vm.getSeverityNum());
        m.put("modified", vm.getModified());
        m.put("submitted", vm.getSubmitted());
        m.put("published", vm.getPublished());
        m.put("withdrawn", vm.getWithdrawn());
        m.put("language", vm.getLanguage());
        m.put("status", vm.getStatus());
        m.put("schemaVersion", vm.getSchemaVersion());
        m.put("confirmedType", vm.getConfirmedType());
        m.put("userId", null); // 不返回内部 id
        m.put("submitterType", vm.getOrganizationId() != null ? "ORG" : "USER");
        // 附带分类 code 与标签 codes（若可用）
        if (categoryMapper != null && vm.getCategoryId() != null) {
            var c = categoryMapper.findById(vm.getCategoryId());
            if (c != null) m.put("categoryCode", c.getCode());
        }
        if (tagMapper != null && vm.getId() != null) {
            var tags = tagMapper.listByVulnerabilityId(vm.getId());
            if (tags != null) {
                m.put("tagCodes", tags.stream().map(t -> t.getCode()).toList());
            }
        }
        // 轻量“影响面”摘要（列表视图用）
        try {
            if (affectedPackageMapper != null && vm.getId() != null) {
                var pkgs = affectedPackageMapper.listByVulnerabilityId(vm.getId());
                int cnt = (pkgs == null) ? 0 : pkgs.size();
                m.put("affectedCount", cnt);
                if (cnt > 0) {
                    var p0 = pkgs.get(0);
                    String label = (p0.getEcosystem() == null ? "" : p0.getEcosystem()) + (p0.getName() == null ? "" : (labelSep((p0.getEcosystem())) + p0.getName()));
                    if (label == null || label.isBlank()) label = p0.getPurl();
                    m.put("affectedLabel", label);
                }
            }
        } catch (Exception ignore) {}
        // 可编辑/可删除标记（前端显隐用，权限以服务端为准）
        try {
            var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
            boolean editable = false;
            boolean deletable = false;
            if (auth != null && auth.getName() != null) {
                User u = userMapper.findByUuid(auth.getName());
                if (u != null) {
                    editable = (vm.getUserId() != null && vm.getUserId().equals(u.getId())) || (vm.getOrganizationId() != null && lnkUserOrganizationMapper.findByOrgIdAndUserId(vm.getOrganizationId(), u.getId()) != null);
                    var link = (vm.getOrganizationId() != null && u.getId() != null) ? lnkUserOrganizationMapper.findByOrgIdAndUserId(vm.getOrganizationId(), u.getId()) : null;
                    deletable = (vm.getUserId() != null && vm.getUserId().equals(u.getId())) || (link != null && link.getRole() == tech.cspioneer.backend.enums.OrganizationRole.ADMIN);
                }
            }
            m.put("editable", editable);
            m.put("deletable", deletable);
        } catch (Exception ignore) {}
        return m;
    }

    private String labelSep(String s) { return (s == null || s.isBlank()) ? "" : " / "; }

    @DeleteMapping("/{uuid}")
    @Operation(summary = "删除漏洞（创建者本人或组织管理员）")
    @org.springframework.security.access.prepost.PreAuthorize("hasAnyRole('USER','ADMIN') or hasAuthority('SCOPE_vuln:write')")
    public ApiResponse<Void> deleteOwned(@PathVariable("uuid") String uuid, Principal principal) {
        service.deleteOwned(principal.getName(), uuid);
        return ApiResponse.success(null);
    }
}
