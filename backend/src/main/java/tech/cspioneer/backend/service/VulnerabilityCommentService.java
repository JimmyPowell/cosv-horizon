package tech.cspioneer.backend.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tech.cspioneer.backend.common.ApiException;
import tech.cspioneer.backend.dto.CommentView;
import tech.cspioneer.backend.entity.User;
import tech.cspioneer.backend.entity.VulnerabilityComment;
import tech.cspioneer.backend.entity.VulnerabilityMetadata;
import tech.cspioneer.backend.mapper.UserMapper;
import tech.cspioneer.backend.mapper.VulnerabilityCommentMapper;

import java.util.List;
import java.util.UUID;

@Service
public class VulnerabilityCommentService {
    private final VulnerabilityCommentMapper commentMapper;
    private final VulnerabilityService vulnerabilityService;
    private final UserMapper userMapper;

    public VulnerabilityCommentService(VulnerabilityCommentMapper commentMapper,
                                       VulnerabilityService vulnerabilityService,
                                       UserMapper userMapper) {
        this.commentMapper = commentMapper;
        this.vulnerabilityService = vulnerabilityService;
        this.userMapper = userMapper;
    }

    public record Page<T>(List<T> items, long total, int page, int size) {}

    public Page<CommentView> list(String userUuid, String vulnUuid, int page, int size) {
        // 权限：依赖详情读取权限（内部包含组织可见性判断）
        VulnerabilityMetadata vm = vulnerabilityService.getByUuid(vulnUuid);

        int limit = Math.max(1, Math.min(100, size <= 0 ? 20 : size));
        int offset = Math.max(0, page <= 0 ? 0 : (page - 1) * limit);

        // 简化：所有人仅看到 ACTIVE 评论
        String status = "ACTIVE";
        List<CommentView> items = commentMapper.listByVulnerabilityId(vm.getId(), status, limit, offset);
        long total = commentMapper.countByVulnerabilityId(vm.getId(), status);
        return new Page<>(items, total, page, limit);
    }

    @Transactional
    public CommentView create(String userUuid, String vulnUuid, String content, String parentUuid) {
        if (content == null || content.isBlank()) throw new ApiException(1001, "评论内容不能为空");
        String c = content.trim();
        if (c.length() > 4000) throw new ApiException(1001, "评论长度超出限制");

        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = vulnerabilityService.getByUuid(vulnUuid);

        Long parentId = null;
        if (parentUuid != null && !parentUuid.isBlank()) {
            var parent = commentMapper.findByUuid(parentUuid);
            if (parent == null) throw new ApiException(404, "父评论不存在");
            if (!vm.getId().equals(parent.getVulnerabilityMetadataId())) throw new ApiException(1001, "父评论不属于该漏洞");
            parentId = parent.getId();
        }

        VulnerabilityComment nc = new VulnerabilityComment();
        nc.setUuid(UUID.randomUUID().toString());
        nc.setVulnerabilityMetadataId(vm.getId());
        nc.setUserId(user.getId());
        nc.setParentId(parentId);
        nc.setContent(c);
        nc.setIsEdited(false);
        nc.setStatus("ACTIVE");
        commentMapper.insert(nc);
        return commentMapper.findViewByUuid(nc.getUuid());
    }

    @Transactional
    public void delete(String userUuid, String vulnUuid, String commentUuid) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = vulnerabilityService.getByUuid(vulnUuid); // 可见性校验
        VulnerabilityComment c = commentMapper.findByUuid(commentUuid);
        if (c == null || !vm.getId().equals(c.getVulnerabilityMetadataId())) throw new ApiException(404, "评论不存在");
        boolean admin = isAdmin();
        if (admin) {
            commentMapper.adminUpdateStatusByUuid(commentUuid, "DELETED");
            return;
        }
        int updated = commentMapper.softDeleteByUuidAndUser(commentUuid, user.getId());
        if (updated == 0) throw new ApiException(1012, "无权删除他人评论");
    }

    private User requireUserByUuid(String uuid) {
        User u = userMapper.findByUuid(uuid);
        if (u == null) throw new ApiException(1005, "用户不存在");
        return u;
    }

    private boolean isAdmin() {
        var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || auth.getAuthorities() == null) return false;
        for (var a : auth.getAuthorities()) { if ("ROLE_ADMIN".equals(a.getAuthority())) return true; }
        return false;
    }
}

