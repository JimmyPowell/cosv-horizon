package tech.cspioneer.backend.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import tech.cspioneer.backend.common.ApiException;
import tech.cspioneer.backend.entity.*;
import tech.cspioneer.backend.mapper.*;
import tech.cspioneer.backend.enums.VulnerabilityStatus;
import tech.cspioneer.backend.enums.ProgrammingLanguage;
import tech.cspioneer.backend.enums.NotificationType;
import tech.cspioneer.backend.enums.NotificationStatus;
import tech.cspioneer.backend.enums.OrganizationStatus;

import java.time.*;
import java.time.format.DateTimeParseException;
import java.util.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import tech.cspioneer.backend.dto.CosvUpsert;

@Service
public class VulnerabilityService {
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(VulnerabilityService.class);
    private final VulnerabilityMetadataMapper vmMapper;
    private final VulnerabilityProjectMapper projectMapper;
    private final TagMapper tagMapper;
    private final LnkVulnTagMapper linkTagMapper;
    private final CosvGeneratedIdMapper idMapper;
    private final CosvFileMapper cosvFileMapper;
    private final UserMapper userMapper;
    private final OrganizationMapper organizationMapper;
    private final LnkUserOrganizationMapper lnkUserOrgMapper;
    private final NotificationMapper notificationMapper;
    private final CategoryMapper categoryMapper;
    // COSV 子表 mappers
    private final VulnerabilityMetadataAliasMapper aliasMapper;
    private final VulnerabilityMetadataRelatedMapper relatedMapper;
    private final VulnerabilityMetadataReferenceMapper referenceMapper;
    private final VulnerabilityMetadataCweMapper cweMapper;
    private final VulnerabilityMetadataTimelineMapper timelineMapper;
    private final VulnerabilityMetadataSeverityMapper severityMapper;
    private final VulnerabilityAffectedPackageMapper affectedPackageMapper;
    private final VulnerabilityAffectedCommitMapper affectedCommitMapper;
    private final VulnerabilityAffectedRangeMapper affectedRangeMapper;
    private final VulnerabilityAffectedRangeEventMapper affectedRangeEventMapper;
    private final VulnerabilityAffectedVersionMapper affectedVersionMapper;
    private final VulnerabilityPatchDetailMapper patchDetailMapper;
    private final VulnerabilityPatchBranchMapper patchBranchMapper;
    private final VulnerabilityPatchTagMapper patchTagMapper;
    private final VulnerabilityContributorMapper contributorMapper;
    private final VulnerabilityCreditMapper creditMapper;
    private final VulnerabilityCreditContactMapper creditContactMapper;
    private final VulnerabilityExploitStatusMapper exploitStatusMapper;
    private final PointsPolicyService pointsPolicyService;
    private final PointsService pointsService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    private static final java.util.EnumSet<VulnerabilityStatus> ALLOWED_STATUS = java.util.EnumSet.of(
            VulnerabilityStatus.ACTIVE,
            VulnerabilityStatus.FIXED,
            VulnerabilityStatus.REJECTED,
            VulnerabilityStatus.PENDING
    );

    @Autowired
    public VulnerabilityService(VulnerabilityMetadataMapper vmMapper,
                                VulnerabilityProjectMapper projectMapper,
                                TagMapper tagMapper,
                                LnkVulnTagMapper linkTagMapper,
                                CosvGeneratedIdMapper idMapper,
                                CosvFileMapper cosvFileMapper,
                                UserMapper userMapper,
                                OrganizationMapper organizationMapper,
                                LnkUserOrganizationMapper lnkUserOrgMapper,
                                NotificationMapper notificationMapper,
                                CategoryMapper categoryMapper,
                                VulnerabilityMetadataAliasMapper aliasMapper,
                                VulnerabilityMetadataRelatedMapper relatedMapper,
                                VulnerabilityMetadataReferenceMapper referenceMapper,
                                VulnerabilityMetadataCweMapper cweMapper,
                                VulnerabilityMetadataTimelineMapper timelineMapper,
                                VulnerabilityMetadataSeverityMapper severityMapper,
                                VulnerabilityAffectedPackageMapper affectedPackageMapper,
                                VulnerabilityAffectedCommitMapper affectedCommitMapper,
                                VulnerabilityAffectedRangeMapper affectedRangeMapper,
                                VulnerabilityAffectedRangeEventMapper affectedRangeEventMapper,
                                VulnerabilityAffectedVersionMapper affectedVersionMapper,
                                VulnerabilityPatchDetailMapper patchDetailMapper,
                                VulnerabilityPatchBranchMapper patchBranchMapper,
                                VulnerabilityPatchTagMapper patchTagMapper,
                                VulnerabilityContributorMapper contributorMapper,
                                VulnerabilityCreditMapper creditMapper,
                                VulnerabilityCreditContactMapper creditContactMapper,
                                VulnerabilityExploitStatusMapper exploitStatusMapper,
                                PointsPolicyService pointsPolicyService,
                                PointsService pointsService,
                                org.springframework.beans.factory.ObjectProvider<tech.cspioneer.backend.search.EsIndexer> esIndexerProvider) {
        this.vmMapper = vmMapper;
        this.projectMapper = projectMapper;
        this.tagMapper = tagMapper;
        this.linkTagMapper = linkTagMapper;
        this.idMapper = idMapper;
        this.cosvFileMapper = cosvFileMapper;
        this.userMapper = userMapper;
        this.organizationMapper = organizationMapper;
        this.lnkUserOrgMapper = lnkUserOrgMapper;
        this.notificationMapper = notificationMapper;
        this.categoryMapper = categoryMapper;
        this.aliasMapper = aliasMapper;
        this.relatedMapper = relatedMapper;
        this.referenceMapper = referenceMapper;
        this.cweMapper = cweMapper;
        this.timelineMapper = timelineMapper;
        this.severityMapper = severityMapper;
        this.affectedPackageMapper = affectedPackageMapper;
        this.affectedCommitMapper = affectedCommitMapper;
        this.affectedRangeMapper = affectedRangeMapper;
        this.affectedRangeEventMapper = affectedRangeEventMapper;
        this.affectedVersionMapper = affectedVersionMapper;
        this.patchDetailMapper = patchDetailMapper;
        this.patchBranchMapper = patchBranchMapper;
        this.patchTagMapper = patchTagMapper;
        this.contributorMapper = contributorMapper;
        this.creditMapper = creditMapper;
        this.creditContactMapper = creditContactMapper;
        this.exploitStatusMapper = exploitStatusMapper;
        this.pointsPolicyService = pointsPolicyService;
        this.pointsService = pointsService;
        this.esIndexer = esIndexerProvider.getIfAvailable();
    }

    private final tech.cspioneer.backend.search.EsIndexer esIndexer;

    // 兼容旧构造已移除：统一使用完整构造函数，避免装配歧义

    public VulnerabilityMetadata getByUuid(String uuid) {
        VulnerabilityMetadata vm = vmMapper.findByUuid(uuid);
        if (vm == null) throw new ApiException(404, "漏洞不存在");
        var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx && "ORG".equalsIgnoreCase(ctx.getSubjectType())) {
            Organization selfOrg = null;
            if (ctx.getOrgUuid() != null) selfOrg = organizationMapper.findByUuid(ctx.getOrgUuid());
            boolean sameOrg = (selfOrg != null && vm.getOrganizationId() != null && selfOrg.getId().equals(vm.getOrganizationId()));
            if (!sameOrg) {
                // 非本组织：仅允许读取公开漏洞（ACTIVE）；个人漏洞亦按公开限制
                if (vm.getStatus() != VulnerabilityStatus.ACTIVE) {
                    throw new ApiException(1012, "组织Key无权读取非公开漏洞");
                }
            }
        } else {
            // 普通用户详情可见性：私有组织仅成员可见；公开组织非成员仅可见 ACTIVE
            if (!isAdmin() && vm.getOrganizationId() != null) {
                Organization org = organizationMapper.findById(vm.getOrganizationId());
                if (org != null) {
                    Long userId = null;
                    try {
                        if (auth != null && auth.getName() != null) userId = requireUserByUuid(auth.getName()).getId();
                    } catch (Exception ignore) {}
                    boolean isMember = (userId != null && lnkUserOrgMapper.findByOrgIdAndUserId(org.getId(), userId) != null);
                    if (!isMember) {
                        if (Boolean.TRUE.equals(org.getIsPublic())) {
                            if (vm.getStatus() != VulnerabilityStatus.ACTIVE) {
                                throw new ApiException(1012, "权限不足");
                            }
                        } else {
                            throw new ApiException(1012, "权限不足");
                        }
                    }
                }
            }
        }
        return vm;
    }

    public List<VulnerabilityMetadata> list(String language, String status, String identifierPrefix, String q, String languagesCSV, String severityLevelsCSV, Float severityGe, Float severityLe, String tagName,
                                            String tagCode,
                                            Boolean mine,
                                            String organizationUuid,
                                            String categoryCode,
                                            String submittedFrom, String submittedTo, String modifiedFrom, String modifiedTo,
                                            String sortBy, String sortOrder,
                                            int page, int size) {
        int limit = Math.max(1, Math.min(100, size <= 0 ? 20 : size));
        int offset = Math.max(0, page <= 0 ? 0 : (page - 1) * limit);
        String orderBy = resolveOrderBy(sortBy, sortOrder);
        Long orgFilter = null;
        Long categoryId = null;
        var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        Long currentUserId = null;
        if (auth != null && auth.getName() != null) {
            try { currentUserId = requireUserByUuid(auth.getName()).getId(); } catch (Exception ignore) {}
        }
        boolean enforceVisibility = false;
        boolean restrictPublicToActive = true;
        // 优先：显式组织过滤（校验成员权限或组织Key）
        if (organizationUuid != null && !organizationUuid.isBlank()) {
            Organization org = organizationMapper.findByUuid(organizationUuid);
            if (org == null) throw new ApiException(404, "组织不存在");
            if (org.getStatus() == OrganizationStatus.DELETED) throw new ApiException(404, "组织不存在");
            if (auth != null && auth.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx && "ORG".equalsIgnoreCase(ctx.getSubjectType())) {
                // 组织API Key仅能查询其所属组织
                if (ctx.getOrgUuid() != null && !organizationUuid.equals(ctx.getOrgUuid())) {
                    throw new ApiException(1012, "组织Key无权读取其他组织漏洞");
                }
            } else if (auth != null && auth.getName() != null) {
                // 普通用户：管理员放行；非管理员则：公开组织允许查看（仅已发布），私有组织要求为成员
                if (!isAdmin()) {
                    User user = requireUserByUuid(auth.getName());
                    LnkUserOrganization link = lnkUserOrgMapper.findByOrgIdAndUserId(org.getId(), user.getId());
                    boolean isMember = (link != null);
                    if (!isMember) {
                        if (Boolean.TRUE.equals(org.getIsPublic())) {
                            // 非成员查看公开组织：限制为已发布漏洞
                            if (status == null || status.isBlank()) {
                                status = tech.cspioneer.backend.enums.VulnerabilityStatus.ACTIVE.name();
                            }
                        } else {
                            ensureMember(org.getId(), user.getId());
                        }
                    }
                }
            }
            orgFilter = org.getId();
        } else {
            // 未显式指定组织
            if (auth != null && auth.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx && "ORG".equalsIgnoreCase(ctx.getSubjectType())) {
                // 组织Key：默认仅读取 ACTIVE
                if (status == null || status.isBlank()) {
                    status = VulnerabilityStatus.ACTIVE.name();
                }
            } else if (!isAdmin()) {
                // 普通用户：应用全局可见性（非成员看不到私有组织；公开组织非成员仅 ACTIVE）
                enforceVisibility = true;
                restrictPublicToActive = true;
            }
        }
        if (categoryCode != null && !categoryCode.isBlank()) {
            Category c = categoryMapper.findByCode(categoryCode);
            if (c != null) categoryId = c.getId();
        }
        // Parse severity levels to flags
        boolean sevCritical = hasLevel(severityLevelsCSV, "CRITICAL");
        boolean sevHigh = hasLevel(severityLevelsCSV, "HIGH");
        boolean sevMedium = hasLevel(severityLevelsCSV, "MEDIUM");
        boolean sevLow = hasLevel(severityLevelsCSV, "LOW");
        String langs = emptyToNull(normalizeCSV(languagesCSV));
        if (langs == null && language != null && !language.isBlank()) langs = language.trim();

        if (log.isDebugEnabled()) {
            log.debug("list() adv filters -> q='{}', identifierPrefix='{}', langs='{}', status='{}', sevLevels='{}', sevGe={}, sevLe={}, org={}, cat={}",
                    q, identifierPrefix, langs, status, severityLevelsCSV, severityGe, severityLe, organizationUuid, categoryCode);
        }
        // mine 模式：仅本人提交或本人管理员组织提交
        if (Boolean.TRUE.equals(mine)) {
            if (currentUserId == null) throw new ApiException(1012, "未登录");
            // 收集管理员组织ID
            java.util.List<Long> adminOrgIds = new java.util.ArrayList<>();
            try {
                var orgs = organizationMapper.listByUserId(currentUserId);
                if (orgs != null) for (var ow : orgs) {
                    if (ow != null && ow.getRole() != null && ow.getRole().equalsIgnoreCase("ADMIN") && ow.getOrganization() != null && ow.getOrganization().getId() != null) {
                        adminOrgIds.add(ow.getOrganization().getId());
                    }
                }
            } catch (Exception ignore) {}
            return vmMapper.listMineByFiltersAdv(
                    currentUserId, adminOrgIds,
                    langs, emptyToNull(status), emptyToNull(identifierPrefix), emptyToNull(q), emptyToNull(tagName), emptyToNull(tagCode),
                    categoryId,
                    emptyToNull(submittedFrom), emptyToNull(submittedTo), emptyToNull(modifiedFrom), emptyToNull(modifiedTo),
                    sevCritical, sevHigh, sevMedium, sevLow,
                    severityGe, severityLe,
                    orderBy, limit, offset);
        }
        // 默认全量过滤
        return vmMapper.listByFiltersAdv(
                langs, emptyToNull(status), emptyToNull(identifierPrefix), emptyToNull(q), emptyToNull(tagName), emptyToNull(tagCode),
                orgFilter, categoryId,
                emptyToNull(submittedFrom), emptyToNull(submittedTo), emptyToNull(modifiedFrom), emptyToNull(modifiedTo),
                sevCritical, sevHigh, sevMedium, sevLow,
                severityGe, severityLe,
                orderBy, limit, offset,
                currentUserId, enforceVisibility, restrictPublicToActive);
    }

    public long count(String language, String status, String identifierPrefix, String q, String languagesCSV, String severityLevelsCSV, Float severityGe, Float severityLe, String tagName,
                      String tagCode,
                      Boolean mine,
                      String organizationUuid,
                      String categoryCode,
                      String submittedFrom, String submittedTo, String modifiedFrom, String modifiedTo) {
        Long orgFilter = null;
        var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        Long currentUserId = null;
        if (auth != null && auth.getName() != null) {
            try { currentUserId = requireUserByUuid(auth.getName()).getId(); } catch (Exception ignore) {}
        }
        boolean enforceVisibility = false;
        boolean restrictPublicToActive = true;
        if (organizationUuid != null && !organizationUuid.isBlank()) {
            Organization org = organizationMapper.findByUuid(organizationUuid);
            if (org == null) throw new ApiException(404, "组织不存在");
            if (org.getStatus() == OrganizationStatus.DELETED) throw new ApiException(404, "组织不存在");
            if (auth != null && auth.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx && "ORG".equalsIgnoreCase(ctx.getSubjectType())) {
                if (ctx.getOrgUuid() != null && !organizationUuid.equals(ctx.getOrgUuid())) {
                    throw new ApiException(1012, "组织Key无权读取其他组织漏洞");
                }
            } else if (auth != null && auth.getName() != null) {
                if (!isAdmin()) {
                    User user = requireUserByUuid(auth.getName());
                    LnkUserOrganization link = lnkUserOrgMapper.findByOrgIdAndUserId(org.getId(), user.getId());
                    boolean isMember = (link != null);
                    if (!isMember) {
                        if (Boolean.TRUE.equals(org.getIsPublic())) {
                            // 统计公开组织的已发布漏洞
                            if (status == null || status.isBlank()) {
                                status = tech.cspioneer.backend.enums.VulnerabilityStatus.ACTIVE.name();
                            }
                        } else {
                            ensureMember(org.getId(), user.getId());
                        }
                    }
                }
            }
            orgFilter = org.getId();
        } else {
            // 未显式指定组织
            if (auth != null && auth.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx && "ORG".equalsIgnoreCase(ctx.getSubjectType())) {
                if (status == null || status.isBlank()) {
                    status = VulnerabilityStatus.ACTIVE.name();
                }
            } else if (!isAdmin()) {
                enforceVisibility = true;
                restrictPublicToActive = true;
            }
        }
        Long categoryId = null;
        if (categoryCode != null && !categoryCode.isBlank()) {
            Category c = categoryMapper.findByCode(categoryCode);
            if (c != null) categoryId = c.getId();
        }
        boolean sevCritical = hasLevel(severityLevelsCSV, "CRITICAL");
        boolean sevHigh = hasLevel(severityLevelsCSV, "HIGH");
        boolean sevMedium = hasLevel(severityLevelsCSV, "MEDIUM");
        boolean sevLow = hasLevel(severityLevelsCSV, "LOW");
        String langs = emptyToNull(normalizeCSV(languagesCSV));
        if (langs == null && language != null && !language.isBlank()) langs = language.trim();

        if (log.isDebugEnabled()) {
            log.debug("count() adv filters -> q='{}', identifierPrefix='{}', langs='{}', status='{}', sevLevels='{}', sevGe={}, sevLe={}, org={}, cat={}",
                    q, identifierPrefix, langs, status, severityLevelsCSV, severityGe, severityLe, organizationUuid, categoryCode);
        }
        if (Boolean.TRUE.equals(mine)) {
            if (currentUserId == null) throw new ApiException(1012, "未登录");
            java.util.List<Long> adminOrgIds = new java.util.ArrayList<>();
            try {
                var orgs = organizationMapper.listByUserId(currentUserId);
                if (orgs != null) for (var ow : orgs) {
                    if (ow != null && ow.getRole() != null && ow.getRole().equalsIgnoreCase("ADMIN") && ow.getOrganization() != null && ow.getOrganization().getId() != null) {
                        adminOrgIds.add(ow.getOrganization().getId());
                    }
                }
            } catch (Exception ignore) {}
            return vmMapper.countMineByFiltersAdv(
                    currentUserId, adminOrgIds,
                    langs, emptyToNull(status), emptyToNull(identifierPrefix), emptyToNull(q), emptyToNull(tagName), emptyToNull(tagCode),
                    categoryId,
                    emptyToNull(submittedFrom), emptyToNull(submittedTo), emptyToNull(modifiedFrom), emptyToNull(modifiedTo),
                    sevCritical, sevHigh, sevMedium, sevLow,
                    severityGe, severityLe);
        }
        return vmMapper.countByFiltersAdv(
                langs, emptyToNull(status), emptyToNull(identifierPrefix), emptyToNull(q), emptyToNull(tagName), emptyToNull(tagCode),
                orgFilter, categoryId,
                emptyToNull(submittedFrom), emptyToNull(submittedTo), emptyToNull(modifiedFrom), emptyToNull(modifiedTo),
                sevCritical, sevHigh, sevMedium, sevLow,
                severityGe, severityLe,
                currentUserId, enforceVisibility, restrictPublicToActive);
    }

    private String resolveOrderBy(String sortBy, String sortOrder) {
        String col = "vm.modified";
        if (sortBy != null) {
            String sb = sortBy.trim().toLowerCase();
            if (sb.equals("modified")) col = "vm.modified";
            else if (sb.equals("severity")) col = "vm.severity_num";
        }
        String dir = (sortOrder != null && sortOrder.trim().equalsIgnoreCase("asc")) ? "ASC" : "DESC";
        return col + " " + dir;
    }

    @Transactional
    public VulnerabilityMetadata create(String userUuid, String organizationUuid,
                                        String summary, String details, Float severityNum, String language,
                                        String categoryCode,
                                        List<String> tags,
                                        List<VulnerabilityProject> projects,
                                        CosvUpsert cosv) {
        // 若为组织 Key，则必须绑定并匹配组织
        var auth0 = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        if (auth0 != null && auth0.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx0) {
            if ("ORG".equalsIgnoreCase(ctx0.getSubjectType())) {
                // 组织 Key：若未显式传组织，默认使用 Key 所属组织；若传入则需匹配
                if (organizationUuid == null || organizationUuid.isBlank()) {
                    organizationUuid = ctx0.getOrgUuid();
                } else if (!organizationUuid.equals(ctx0.getOrgUuid())) {
                    throw new ApiException(1012, "组织Key无权操作其他组织");
                }
            } else if ("USER".equalsIgnoreCase(ctx0.getSubjectType())) {
                // 个人 Key：不得代表组织提交
                if (organizationUuid != null && !organizationUuid.isBlank()) {
                    throw new ApiException(1012, "个人Key不得代表组织提交");
                }
            }
        }
        User user = requireUserByUuid(userUuid);
        Long orgId = null;
        if (organizationUuid != null && !organizationUuid.isBlank()) {
            Organization org = organizationMapper.findByUuid(organizationUuid);
            if (org == null) throw new ApiException(404, "组织不存在");
            if (org.getStatus() != OrganizationStatus.ACTIVE) {
                throw new ApiException(403, "组织当前状态不允许以组织身份提交");
            }
            ensureMember(org.getId(), user.getId());
            orgId = org.getId();
        }

        String identifier = generateIdentifier();
        CosvFile file = new CosvFile();
        file.setUuid(UUID.randomUUID().toString());
        file.setIdentifier(identifier);
        file.setPrevCosvFileId(null);
        file.setUserId(user.getId());
        file.setSchemaVersion((cosv != null && cosv.getSchemaVersion() != null && !cosv.getSchemaVersion().isBlank()) ? cosv.getSchemaVersion() : "1.0.0");
        file.setRawCosvFileId(null);
        cosvFileMapper.insert(file);

        VulnerabilityMetadata vm = new VulnerabilityMetadata();
        vm.setUuid(UUID.randomUUID().toString());
        vm.setIdentifier(identifier);
        vm.setSummary(summary);
        vm.setDetails(details);
        vm.setSeverityNum(severityNum);
        vm.setSchemaVersion((cosv != null && cosv.getSchemaVersion() != null && !cosv.getSchemaVersion().isBlank()) ? cosv.getSchemaVersion() : "1.0.0");
        if (language != null && !language.isBlank()) {
            vm.setLanguage(ProgrammingLanguage.fromCode(language));
        } else {
            vm.setLanguage(null);
        }
        // 初始状态：管理员/认证组织 -> ACTIVE；否则 PENDING
        boolean admin = isAdmin();
        if (admin) {
            vm.setStatus(VulnerabilityStatus.ACTIVE);
        } else if (orgId != null) {
            if (organizationUuid != null && !organizationUuid.isBlank()) {
                Organization org = organizationMapper.findByUuid(organizationUuid);
                if (org != null && Boolean.TRUE.equals(org.getIsVerified())) {
                    vm.setStatus(VulnerabilityStatus.ACTIVE);
                } else {
                    vm.setStatus(VulnerabilityStatus.PENDING);
                }
            } else {
                vm.setStatus(VulnerabilityStatus.PENDING);
            }
        } else {
            vm.setStatus(VulnerabilityStatus.PENDING);
        }
        vm.setUserId(user.getId());
        vm.setOrganizationId(orgId);
        vm.setLatestCosvFileId(file.getId());
        if (categoryCode != null && !categoryCode.isBlank()) {
            Category c = categoryMapper.findByCode(categoryCode);
            if (c == null) throw new ApiException(400, "分类不存在");
            vm.setCategoryId(c.getId());
        }
        vmMapper.insert(vm);

        // 顶层：published/withdrawn/confirmedType/databaseSpecific（可选）
        if (cosv != null) {
            VulnerabilityMetadata patch = new VulnerabilityMetadata();
            patch.setUuid(vm.getUuid());
            patch.setSchemaVersion(cosv.getSchemaVersion());
            patch.setConfirmedType(cosv.getConfirmedType());
            patch.setPublished(parseRfc3339Nullable(cosv.getPublished()));
            patch.setWithdrawn(parseRfc3339Nullable(cosv.getWithdrawn()));
            patch.setDatabaseSpecific(stringifyJsonOrNull(cosv.getDatabaseSpecific()));
            vmMapper.updateCosvExtras(patch);
        }

        if (tags != null) {
            for (String key : tags) {
                if (key == null) continue;
                String nm = key.trim();
                if (nm.isBlank()) continue;
                Tag t = tagMapper.findByCode(nm);
                if (t == null) t = tagMapper.findByName(nm);
                if (t == null) throw new ApiException(400, "标签不存在: " + nm);
                linkTagMapper.link(vm.getId(), t.getId());
            }
        }

        if (projects != null) {
            for (VulnerabilityProject p : projects) {
                if (p.getName() == null || p.getName().isBlank()) continue;
                p.setUuid(UUID.randomUUID().toString());
                p.setVulnerabilityMetadataId(vm.getId());
                if (p.getType() == null || p.getType().isBlank()) p.setType("AFFECTED");
                projectMapper.insert(p);
            }
        }

        // COSV 子表写入（若提供）
        if (cosv != null) {
            upsertCosvChildrenReplace(vm, cosv);

            // 若提供 severity[]，回填 severity_num（取最大）
            Float agg = aggregateSeverityNum(cosv.getSeverity(), severityNum);
            if (agg != null && !Objects.equals(agg, vm.getSeverityNum())) {
                VulnerabilityMetadata v2 = new VulnerabilityMetadata();
                v2.setUuid(vm.getUuid());
                v2.setSeverityNum(agg);
                vmMapper.updateBasic(v2);
            }
        }

        VulnerabilityMetadata saved = vmMapper.findByUuid(vm.getUuid());
        // ES 增量索引（可用时）
        if (esIndexer != null && saved != null) {
            safeIndex(saved.getUuid());
        }
        // 积分发放：SUBMITTED；若创建即 ACTIVE 再发放 PUBLISHED
        try {
            String orgUuid0 = organizationUuid;
            if ((orgUuid0 == null || orgUuid0.isBlank()) && saved.getOrganizationId() != null) {
                Organization org0 = organizationMapper.findById(saved.getOrganizationId());
                if (org0 != null) orgUuid0 = org0.getUuid();
            }
            awardPointsForEvent(userUuid, orgUuid0, "SUBMITTED", saved.getSeverityNum(), saved.getUuid());
            if (saved.getStatus() == VulnerabilityStatus.ACTIVE) {
                awardPointsForEvent(userUuid, orgUuid0, "PUBLISHED", saved.getSeverityNum(), saved.getUuid());
            }
        } catch (Exception ignore) {}
        return saved;
    }

    // 兼容旧签名
    @Transactional
    public VulnerabilityMetadata create(String userUuid, String organizationUuid,
                                        String summary, String details, Float severityNum, String language,
                                        String categoryCode,
                                        List<String> tags,
                                        List<VulnerabilityProject> projects) {
        return create(userUuid, organizationUuid, summary, details, severityNum, language, categoryCode, tags, projects, null);
    }

    // 新增：带 rawCosvFile 关联的创建（供文件导入使用）
    @Transactional
    public VulnerabilityMetadata createWithRaw(String userUuid, String organizationUuid,
                                        String summary, String details, Float severityNum, String language,
                                        String categoryCode,
                                        List<String> tags,
                                        List<VulnerabilityProject> projects,
                                        CosvUpsert cosv,
                                        Long rawCosvFileId) {
        var auth0 = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        if (auth0 != null && auth0.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx0) {
            if ("ORG".equalsIgnoreCase(ctx0.getSubjectType())) {
                if (organizationUuid == null || organizationUuid.isBlank()) {
                    organizationUuid = ctx0.getOrgUuid();
                } else if (!organizationUuid.equals(ctx0.getOrgUuid())) {
                    throw new ApiException(1012, "组织Key无权操作其他组织");
                }
            } else if ("USER".equalsIgnoreCase(ctx0.getSubjectType())) {
                if (organizationUuid != null && !organizationUuid.isBlank()) {
                    throw new ApiException(1012, "个人Key不得代表组织提交");
                }
            }
        }
        User user = requireUserByUuid(userUuid);
        Long orgId = null;
        if (organizationUuid != null && !organizationUuid.isBlank()) {
            Organization org = organizationMapper.findByUuid(organizationUuid);
            if (org == null) throw new ApiException(404, "组织不存在");
            // 仅 ACTIVE 组织允许以组织身份提交（与表单创建保持一致）
            if (org.getStatus() != OrganizationStatus.ACTIVE) {
                throw new ApiException(403, "组织当前状态不允许以组织身份提交");
            }
            ensureMember(org.getId(), user.getId());
            orgId = org.getId();
        }

        String identifier = generateIdentifier();
        CosvFile file = new CosvFile();
        file.setUuid(UUID.randomUUID().toString());
        file.setIdentifier(identifier);
        file.setPrevCosvFileId(null);
        file.setUserId(user.getId());
        file.setSchemaVersion((cosv != null && cosv.getSchemaVersion() != null && !cosv.getSchemaVersion().isBlank()) ? cosv.getSchemaVersion() : "1.0.0");
        file.setRawCosvFileId(rawCosvFileId);
        cosvFileMapper.insert(file);

        VulnerabilityMetadata vm = new VulnerabilityMetadata();
        vm.setUuid(UUID.randomUUID().toString());
        vm.setIdentifier(identifier);
        vm.setSummary(summary);
        vm.setDetails(details);
        vm.setSeverityNum(severityNum);
        vm.setSchemaVersion((cosv != null && cosv.getSchemaVersion() != null && !cosv.getSchemaVersion().isBlank()) ? cosv.getSchemaVersion() : "1.0.0");
        if (language != null && !language.isBlank()) {
            vm.setLanguage(ProgrammingLanguage.fromCode(language));
        } else {
            vm.setLanguage(null);
        }
        boolean admin = isAdmin();
        if (admin) {
            vm.setStatus(VulnerabilityStatus.ACTIVE);
        } else if (orgId != null) {
            if (organizationUuid != null && !organizationUuid.isBlank()) {
                Organization org = organizationMapper.findByUuid(organizationUuid);
                // 仅认证组织（isVerified == true）默认直接 ACTIVE，否则 PENDING
                if (org != null && Boolean.TRUE.equals(org.getIsVerified())) {
                    vm.setStatus(VulnerabilityStatus.ACTIVE);
                } else {
                    vm.setStatus(VulnerabilityStatus.PENDING);
                }
            } else {
                vm.setStatus(VulnerabilityStatus.PENDING);
            }
        } else {
            vm.setStatus(VulnerabilityStatus.PENDING);
        }
        vm.setUserId(user.getId());
        vm.setOrganizationId(orgId);
        vm.setLatestCosvFileId(file.getId());
        if (categoryCode != null && !categoryCode.isBlank()) {
            Category c = categoryMapper.findByCode(categoryCode);
            if (c == null) throw new ApiException(400, "分类不存在");
            vm.setCategoryId(c.getId());
        }
        vmMapper.insert(vm);

        // 标签关联（若传入），与表单创建逻辑保持一致
        if (tags != null) {
            for (String key : tags) {
                if (key == null) continue;
                String nm = key.trim();
                if (nm.isBlank()) continue;
                Tag t = tagMapper.findByCode(nm);
                if (t == null) t = tagMapper.findByName(nm);
                if (t == null) throw new ApiException(400, "标签不存在: " + nm);
                linkTagMapper.link(vm.getId(), t.getId());
            }
        }

        if (cosv != null) {
            VulnerabilityMetadata patch = new VulnerabilityMetadata();
            patch.setUuid(vm.getUuid());
            patch.setSchemaVersion(cosv.getSchemaVersion());
            patch.setConfirmedType(cosv.getConfirmedType());
            patch.setPublished(parseRfc3339Nullable(cosv.getPublished()));
            patch.setWithdrawn(parseRfc3339Nullable(cosv.getWithdrawn()));
            patch.setDatabaseSpecific(stringifyJsonOrNull(cosv.getDatabaseSpecific()));
            vmMapper.updateCosvExtras(patch);
            upsertCosvChildrenReplace(vm, cosv);
            Float agg = aggregateSeverityNum(cosv.getSeverity(), severityNum);
            if (agg != null && !Objects.equals(agg, vm.getSeverityNum())) {
                VulnerabilityMetadata v2 = new VulnerabilityMetadata();
                v2.setUuid(vm.getUuid());
                v2.setSeverityNum(agg);
                vmMapper.updateBasic(v2);
            }
        }
        VulnerabilityMetadata saved = vmMapper.findByUuid(vm.getUuid());
        if (esIndexer != null && saved != null) safeIndex(saved.getUuid());
        // 积分：SUBMITTED；若创建即 ACTIVE 同时发放 PUBLISHED
        try {
            String orgUuid0 = organizationUuid;
            if ((orgUuid0 == null || orgUuid0.isBlank()) && saved.getOrganizationId() != null) {
                Organization org0 = organizationMapper.findById(saved.getOrganizationId());
                if (org0 != null) orgUuid0 = org0.getUuid();
            }
            awardPointsForEvent(userUuid, orgUuid0, "SUBMITTED", saved.getSeverityNum(), saved.getUuid());
            if (saved.getStatus() == VulnerabilityStatus.ACTIVE) {
                awardPointsForEvent(userUuid, orgUuid0, "PUBLISHED", saved.getSeverityNum(), saved.getUuid());
            }
        } catch (Exception ignore) {}
        return saved;
    }

    @Transactional
    public VulnerabilityMetadata update(String userUuid, String vulnUuid,
                                        String summary, String details, Float severityNum, String language, String status,
                                        String categoryCode,
                                        CosvUpsert cosv) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        ensureCanEdit(user, vm);
        VulnerabilityStatus newStatus = null;
        if (status != null && !status.isBlank()) {
            newStatus = VulnerabilityStatus.fromCode(status);
            if (!ALLOWED_STATUS.contains(newStatus)) {
                throw new ApiException(1011, "非法状态");
            }
            // 非管理员不得直接将状态置为 ACTIVE
            if (newStatus == VulnerabilityStatus.ACTIVE && !isAdmin()) {
                throw new ApiException(1012, "权限不足");
            }
        }
        VulnerabilityStatus oldStatus = vm.getStatus();
        VulnerabilityMetadata changes = new VulnerabilityMetadata();
        changes.setUuid(vulnUuid);
        changes.setSummary(summary);
        changes.setDetails(details);
        changes.setSeverityNum(severityNum);
        if (language != null && !language.isBlank()) {
            changes.setLanguage(ProgrammingLanguage.fromCode(language));
        }
        changes.setStatus(newStatus);
        boolean clearCategory = false;
        if (categoryCode != null) {
            if (categoryCode.isBlank()) {
                clearCategory = true;
            } else {
                Category c = categoryMapper.findByCode(categoryCode);
                if (c == null) throw new ApiException(400, "分类不存在");
                changes.setCategoryId(c.getId());
            }
        }
        vmMapper.updateBasic(changes);
        if (clearCategory) {
            vmMapper.clearCategoryByUuid(vulnUuid);
        }

        boolean wroteCosvChild = false;
        // 顶层 COSV 可选更新
        if (cosv != null) {
            VulnerabilityMetadata patch = new VulnerabilityMetadata();
            patch.setUuid(vm.getUuid());
            patch.setSchemaVersion(cosv.getSchemaVersion());
            patch.setConfirmedType(cosv.getConfirmedType());
            patch.setPublished(parseRfc3339Nullable(cosv.getPublished()));
            patch.setWithdrawn(parseRfc3339Nullable(cosv.getWithdrawn()));
            patch.setDatabaseSpecific(stringifyJsonOrNull(cosv.getDatabaseSpecific()));
            vmMapper.updateCosvExtras(patch);

            // 替换式子表更新：仅对提供的子结构执行
            wroteCosvChild = upsertCosvChildrenOnUpdate(vm, cosv) || wroteCosvChild;

            // severity 聚合回填
            Float agg = aggregateSeverityNum(cosv.getSeverity(), severityNum);
            if (agg != null) {
                VulnerabilityMetadata v2 = new VulnerabilityMetadata();
                v2.setUuid(vm.getUuid());
                v2.setSeverityNum(agg);
                vmMapper.updateBasic(v2);
            }
        }
        VulnerabilityMetadata updated = vmMapper.findByUuid(vulnUuid);

        // 版本链：若有 COSV 字段或子表变化，追加 cosv_file 版本
        if (cosv != null || changes.getSummary() != null || changes.getDetails() != null || changes.getSeverityNum() != null || changes.getLanguage() != null || changes.getStatus() != null || changes.getCategoryId() != null || wroteCosvChild) {
            CosvFile file = new CosvFile();
            file.setUuid(UUID.randomUUID().toString());
            file.setIdentifier(updated.getIdentifier());
            file.setPrevCosvFileId(updated.getLatestCosvFileId());
            file.setUserId(user.getId());
            file.setSchemaVersion(updated.getSchemaVersion() != null ? updated.getSchemaVersion() : "1.0.0");
            file.setRawCosvFileId(null);
            cosvFileMapper.insert(file);
            vmMapper.updateLatestCosvFileIdById(updated.getId(), file.getId());
            updated = vmMapper.findByUuid(vulnUuid);
        }
        if (newStatus != null && oldStatus != null && oldStatus != updated.getStatus()) {
            // 通知创建者（若操作者不是创建者）
            if (updated.getUserId() != null && !updated.getUserId().equals(user.getId())) {
                Notification n = new Notification();
                n.setUuid(java.util.UUID.randomUUID().toString());
                n.setType(NotificationType.VULNERABILITY_REPORT);
                n.setTargetId(updated.getId());
                n.setUserId(updated.getUserId());
                n.setSenderId(user.getId());
                n.setTitle("漏洞状态变更");
                n.setContent("漏洞 " + updated.getIdentifier() + " 状态已变更为 " + updated.getStatus());
                n.setIsRead(false);
                n.setStatus(NotificationStatus.ACTIVE);
                notificationMapper.insert(n);
                try {
                    // 指向前端漏洞详情页，使用 uuid
                    String action = "/vulnerabilities/" + updated.getUuid();
                    notificationMapper.updateActionUrlByUuid(n.getUuid(), action);
                } catch (Exception ignore) {}
            }
            // 触发积分：状态变更到 ACTIVE 时发放 PUBLISHED
            try {
                if (updated.getStatus() == VulnerabilityStatus.ACTIVE) {
                    String submitterUuid = null;
                    if (updated.getUserId() != null) submitterUuid = userMapper.findUuidById(updated.getUserId());
                    String orgUuid0 = null;
                    if (updated.getOrganizationId() != null) {
                        Organization o = organizationMapper.findById(updated.getOrganizationId());
                        if (o != null) orgUuid0 = o.getUuid();
                    }
                    awardPointsForEvent(submitterUuid, orgUuid0, "PUBLISHED", updated.getSeverityNum(), updated.getUuid());
                }
            } catch (Exception ignore) {}
        }
        return updated;
    }

    private void awardPointsForEvent(String userUuid, String orgUuid, String event, Float severityNum, String vulnUuid) {
        try {
            PointsPolicyService.PreviewReq r = new PointsPolicyService.PreviewReq();
            r.event = event;
            r.severityNum = severityNum == null ? null : severityNum.doubleValue();
            r.severityLevel = null;
            var out = (orgUuid != null && !orgUuid.isBlank()) ? pointsPolicyService.previewForOrg(orgUuid, r) : pointsPolicyService.preview(r);
            String idem = "vuln:" + vulnUuid + ":" + event;
            String refType = "VULN";
            String reason = "VULN_" + event;
            if (userUuid != null && out.userDelta != 0) {
                pointsService.addUserPoints(userUuid, out.userDelta, reason, refType, vulnUuid, idem);
            }
            if (orgUuid != null && !orgUuid.isBlank() && out.orgDelta != 0) {
                pointsService.addOrgPoints(orgUuid, out.orgDelta, reason, refType, vulnUuid, idem);
            }
        } catch (Exception ignore) {}
    }

    // 兼容旧签名
    @Transactional
    public VulnerabilityMetadata update(String userUuid, String vulnUuid,
                                        String summary, String details, Float severityNum, String language, String status,
                                        String categoryCode) {
        return update(userUuid, vulnUuid, summary, details, severityNum, language, status, categoryCode, null);
    }

    // 新增：带 rawCosvFile 关联的更新（供文件导入使用）
    @Transactional
    public VulnerabilityMetadata updateWithRaw(String userUuid, String vulnUuid,
                                               String summary, String details, Float severityNum, String language, String status,
                                               String categoryCode,
                                               CosvUpsert cosv,
                                               Long rawCosvFileId) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        ensureCanEdit(user, vm);

        VulnerabilityStatus newStatus = null;
        if (status != null && !status.isBlank()) {
            newStatus = VulnerabilityStatus.fromCode(status);
            if (!ALLOWED_STATUS.contains(newStatus)) {
                throw new ApiException(1011, "非法状态");
            }
            if (newStatus == VulnerabilityStatus.ACTIVE && !isAdmin()) {
                throw new ApiException(1012, "权限不足");
            }
        }

        VulnerabilityStatus oldStatus = vm.getStatus();
        VulnerabilityMetadata changes = new VulnerabilityMetadata();
        changes.setUuid(vulnUuid);
        changes.setSummary(summary);
        changes.setDetails(details);
        changes.setSeverityNum(severityNum);
        if (language != null && !language.isBlank()) {
            changes.setLanguage(ProgrammingLanguage.fromCode(language));
        }
        changes.setStatus(newStatus);

        boolean clearCategory = false;
        if (categoryCode != null) {
            if (categoryCode.isBlank()) {
                clearCategory = true;
            } else {
                Category c = categoryMapper.findByCode(categoryCode);
                if (c == null) throw new ApiException(400, "分类不存在");
                changes.setCategoryId(c.getId());
            }
        }
        vmMapper.updateBasic(changes);
        if (clearCategory) {
            vmMapper.clearCategoryByUuid(vulnUuid);
        }

        boolean wroteCosvChild = false;
        if (cosv != null) {
            VulnerabilityMetadata patch = new VulnerabilityMetadata();
            patch.setUuid(vm.getUuid());
            patch.setSchemaVersion(cosv.getSchemaVersion());
            patch.setConfirmedType(cosv.getConfirmedType());
            patch.setPublished(parseRfc3339Nullable(cosv.getPublished()));
            patch.setWithdrawn(parseRfc3339Nullable(cosv.getWithdrawn()));
            patch.setDatabaseSpecific(stringifyJsonOrNull(cosv.getDatabaseSpecific()));
            vmMapper.updateCosvExtras(patch);

            wroteCosvChild = upsertCosvChildrenOnUpdate(vm, cosv) || wroteCosvChild;

            Float agg = aggregateSeverityNum(cosv.getSeverity(), severityNum);
            if (agg != null) {
                VulnerabilityMetadata v2 = new VulnerabilityMetadata();
                v2.setUuid(vm.getUuid());
                v2.setSeverityNum(agg);
                vmMapper.updateBasic(v2);
            }
        }

        VulnerabilityMetadata updated = vmMapper.findByUuid(vulnUuid);

        if (cosv != null || changes.getSummary() != null || changes.getDetails() != null || changes.getSeverityNum() != null || changes.getLanguage() != null || changes.getStatus() != null || changes.getCategoryId() != null || wroteCosvChild) {
            CosvFile file = new CosvFile();
            file.setUuid(UUID.randomUUID().toString());
            file.setIdentifier(updated.getIdentifier());
            file.setPrevCosvFileId(updated.getLatestCosvFileId());
            file.setUserId(user.getId());
            file.setSchemaVersion(updated.getSchemaVersion() != null ? updated.getSchemaVersion() : "1.0.0");
            file.setRawCosvFileId(rawCosvFileId);
            cosvFileMapper.insert(file);
            vmMapper.updateLatestCosvFileIdById(updated.getId(), file.getId());
            updated = vmMapper.findByUuid(vulnUuid);
        }

        if (newStatus != null && oldStatus != null && oldStatus != updated.getStatus()) {
            if (updated.getUserId() != null && !updated.getUserId().equals(user.getId())) {
                Notification n = new Notification();
                n.setUuid(java.util.UUID.randomUUID().toString());
                n.setType(NotificationType.VULNERABILITY_REPORT);
                n.setTargetId(updated.getId());
                n.setUserId(updated.getUserId());
                n.setSenderId(user.getId());
                n.setTitle("漏洞状态变更");
                n.setContent("漏洞 " + updated.getIdentifier() + " 状态已变更为 " + updated.getStatus());
                n.setIsRead(false);
                n.setStatus(NotificationStatus.ACTIVE);
                notificationMapper.insert(n);
                try {
                    String action = "/vulnerabilities/" + updated.getUuid();
                    notificationMapper.updateActionUrlByUuid(n.getUuid(), action);
                } catch (Exception ignore) {}
            }
        }
        return updated;
    }

    // ========== COSV 视图聚合 ==========
    public Map<String, Object> buildCosvView(VulnerabilityMetadata vm) {
        Map<String, Object> m = new LinkedHashMap<>();
        m.put("id", vm.getIdentifier());
        m.put("schema_version", vm.getSchemaVersion());
        m.put("summary", vm.getSummary());
        m.put("details", vm.getDetails());
        m.put("published", toRfc3339(vm.getPublished()));
        m.put("withdrawn", toRfc3339(vm.getWithdrawn()));
        m.put("modified", toRfc3339(vm.getModified()));
        m.put("confirmed_type", vm.getConfirmedType());
        m.put("database_specific", parseJsonOrRaw(vm.getDatabaseSpecific()));

        // 关联
        m.put("aliases", aliasMapper.listByVulnerabilityId(vm.getId()).stream().map(a -> a.getValue()).toList());
        m.put("related", relatedMapper.listByVulnerabilityId(vm.getId()).stream().map(a -> a.getValue()).toList());
        var refs = referenceMapper.listByVulnerabilityId(vm.getId());
        m.put("references", refs == null ? List.of() : refs.stream().map(r -> {
            Map<String, Object> x = new LinkedHashMap<>(); x.put("type", r.getType()); x.put("url", r.getUrl()); return x; }).toList());

        // CWE
        var cwes = cweMapper.listByVulnerabilityId(vm.getId());
        m.put("cwe_ids", cwes.stream().map(c -> c.getCweId()).filter(Objects::nonNull).toList());
        m.put("cwe_names", cwes.stream().map(c -> c.getCweName()).filter(Objects::nonNull).toList());

        // 时间线
        var tls = timelineMapper.listByVulnerabilityId(vm.getId());
        m.put("time_line", tls.stream().map(t -> {
            Map<String, Object> x = new LinkedHashMap<>(); x.put("type", t.getType()); x.put("value", toRfc3339(t.getValue())); return x; }).toList());

        // 危险性（多量表）
        var sevs = severityMapper.listByVulnerabilityId(vm.getId());
        m.put("severity", sevs.stream().map(s -> {
            Map<String, Object> x = new LinkedHashMap<>(); x.put("type", s.getType()); x.put("score", s.getScore()); x.put("level", s.getLevel()); x.put("score_num", s.getScoreNum()); return x; }).toList());

        // 受影响面
        List<Map<String, Object>> affected = new ArrayList<>();
        var pkgs = affectedPackageMapper.listByVulnerabilityId(vm.getId());
        if (pkgs != null) for (var p : pkgs) {
            Map<String, Object> a = new LinkedHashMap<>();
            Map<String, Object> pkg = new LinkedHashMap<>();
            pkg.put("ecosystem", p.getEcosystem()); pkg.put("name", p.getName()); pkg.put("purl", p.getPurl()); pkg.put("language", p.getLanguage()); pkg.put("repository", p.getRepository()); pkg.put("home_page", p.getHomePage()); pkg.put("edition", p.getEdition());
            // commits
            var commits = affectedCommitMapper.listByPackageId(p.getId());
            pkg.put("introduced_commits", commits.stream().filter(c -> "INTRODUCED".equalsIgnoreCase(c.getCommitType())).map(c -> c.getCommitId()).toList());
            pkg.put("fixed_commits", commits.stream().filter(c -> "FIXED".equalsIgnoreCase(c.getCommitType())).map(c -> c.getCommitId()).toList());
            // pkg extensions
            pkg.put("ecosystem_specific", parseJsonOrRaw(p.getEcosystemSpecific()));
            pkg.put("database_specific", parseJsonOrRaw(p.getDatabaseSpecific()));
            a.put("package", pkg);

            // ranges
            var ranges = affectedRangeMapper.listByPackageId(p.getId());
            List<Map<String, Object>> rangeDtos = new ArrayList<>();
            for (var r : ranges) {
                Map<String, Object> rd = new LinkedHashMap<>(); rd.put("type", r.getType()); rd.put("repo", r.getRepo());
                var events = affectedRangeEventMapper.listByRangeId(r.getId());
                List<Map<String, String>> evDtos = new ArrayList<>();
                for (var e : events) { Map<String, String> ev = new LinkedHashMap<>(); ev.put(e.getEventType(), e.getValue()); evDtos.add(ev);} 
                rd.put("events", evDtos);
                rd.put("database_specific", parseJsonOrRaw(r.getDatabaseSpecific()));
                rangeDtos.add(rd);
            }
            a.put("ranges", rangeDtos);

            // versions
            var vers = affectedVersionMapper.listByPackageId(p.getId());
            a.put("versions", vers.stream().map(v -> v.getVersion()).toList());

            // affected-level extensions: 落在 package.database_specific 中的 severity 原文
            a.put("ecosystem_specific", null);
            a.put("database_specific", null);
            affected.add(a);
        }
        m.put("affected", affected);

        // 扩展
        var pdls = patchDetailMapper.listByVulnerabilityId(vm.getId());
        List<Map<String, Object>> patchDtos = new ArrayList<>();
        for (var pd : pdls) {
            Map<String, Object> x = new LinkedHashMap<>();
            x.put("patch_url", pd.getPatchUrl()); x.put("issue_url", pd.getIssueUrl()); x.put("main_language", pd.getMainLanguage()); x.put("author", pd.getAuthor()); x.put("committer", pd.getCommitter());
            var branches = patchBranchMapper.listByPatchDetailId(pd.getId());
            var tags = patchTagMapper.listByPatchDetailId(pd.getId());
            x.put("branches", branches.stream().map(b -> b.getName()).toList());
            x.put("tags", tags.stream().map(t -> t.getName()).toList());
            patchDtos.add(x);
        }
        m.put("patch_details", patchDtos);

        var contribs = contributorMapper.listByVulnerabilityId(vm.getId());
        m.put("contributors", contribs.stream().map(c -> { Map<String,Object> x=new LinkedHashMap<>(); x.put("org",c.getOrg()); x.put("name",c.getName()); x.put("email",c.getEmail()); x.put("contributions",c.getContributions()); return x;}).toList());

        var credits = creditMapper.listByVulnerabilityId(vm.getId());
        List<Map<String, Object>> creditDtos = new ArrayList<>();
        for (var cr : credits) {
            Map<String, Object> x = new LinkedHashMap<>(); x.put("name", cr.getName()); x.put("type", cr.getType());
            var contacts = creditContactMapper.listByCreditId(cr.getId());
            x.put("contact", contacts.stream().map(cc -> cc.getContact()).toList());
            creditDtos.add(x);
        }
        m.put("credits", creditDtos);

        var exs = exploitStatusMapper.listByVulnerabilityId(vm.getId());
        m.put("exploit_status", exs.stream().map(e -> e.getStatus()).toList());

        return m;
    }

    // ========== COSV 写入辅助 ==========
    private void upsertCosvChildrenReplace(VulnerabilityMetadata vm, CosvUpsert cosv) {
        // 全量清空再写入（用于创建路径，或更新时显式替换时调用）
        replaceAliases(vm, cosv.getAliases());
        replaceRelated(vm, cosv.getRelated());
        replaceReferences(vm, cosv.getReferences());
        replaceCwe(vm, cosv.getCweIds(), cosv.getCweNames());
        replaceTimeline(vm, cosv.getTimeLine());
        replaceSeverities(vm, cosv.getSeverity());
        replaceAffected(vm, cosv.getAffected());
        replacePatchDetails(vm, cosv.getPatchDetails());
        replaceContributors(vm, cosv.getContributors());
        replaceCredits(vm, cosv.getCredits());
        replaceExploitStatus(vm, cosv.getExploitStatus());
    }

    private boolean upsertCosvChildrenOnUpdate(VulnerabilityMetadata vm, CosvUpsert cosv) {
        boolean changed = false;
        if (cosv.getAliases() != null) { replaceAliases(vm, cosv.getAliases()); changed = true; }
        if (cosv.getRelated() != null) { replaceRelated(vm, cosv.getRelated()); changed = true; }
        if (cosv.getReferences() != null) { replaceReferences(vm, cosv.getReferences()); changed = true; }
        if (cosv.getCweIds() != null || cosv.getCweNames() != null) { replaceCwe(vm, cosv.getCweIds(), cosv.getCweNames()); changed = true; }
        if (cosv.getTimeLine() != null) { replaceTimeline(vm, cosv.getTimeLine()); changed = true; }
        if (cosv.getSeverity() != null) { replaceSeverities(vm, cosv.getSeverity()); changed = true; }
        if (cosv.getAffected() != null) { replaceAffected(vm, cosv.getAffected()); changed = true; }
        if (cosv.getPatchDetails() != null) { replacePatchDetails(vm, cosv.getPatchDetails()); changed = true; }
        if (cosv.getContributors() != null) { replaceContributors(vm, cosv.getContributors()); changed = true; }
        if (cosv.getCredits() != null) { replaceCredits(vm, cosv.getCredits()); changed = true; }
        if (cosv.getExploitStatus() != null) { replaceExploitStatus(vm, cosv.getExploitStatus()); changed = true; }
        return changed;
    }

    private void replaceAliases(VulnerabilityMetadata vm, List<String> values) {
        if (values == null) return;
        // 全局唯一校验：任意别名只能归属一个漏洞
        for (String v : values) {
            if (v == null) continue;
            String t = v.trim();
            if (t.isEmpty()) continue;
            String conflictUuid = aliasMapper.findVulnerabilityUuidByAlias(t);
            if (conflictUuid != null) {
                // 自身别名不算冲突；否则拒绝
                if (vm.getUuid() == null || !conflictUuid.equals(vm.getUuid())) {
                    throw new ApiException(1015, "别名冲突: " + t + " 已被漏洞 " + conflictUuid + " 使用");
                }
            }
        }
        aliasMapper.deleteByVulnerabilityId(vm.getId());
        for (String v : values) {
            if (v == null) continue;
            String t = v.trim();
            if (t.isEmpty()) continue;
            tech.cspioneer.backend.entity.VulnerabilityMetadataAlias e = new tech.cspioneer.backend.entity.VulnerabilityMetadataAlias();
            e.setVulnerabilityMetadataId(vm.getId());
            e.setValue(t);
            aliasMapper.insert(e);
        }
    }

    private void replaceRelated(VulnerabilityMetadata vm, List<String> values) {
        if (values == null) return;
        relatedMapper.deleteByVulnerabilityId(vm.getId());
        for (String v : values) { if (v == null || v.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityMetadataRelated e = new tech.cspioneer.backend.entity.VulnerabilityMetadataRelated(); e.setVulnerabilityMetadataId(vm.getId()); e.setValue(v.trim()); relatedMapper.insert(e);}    }

    private void replaceReferences(VulnerabilityMetadata vm, List<CosvUpsert.Reference> refs) {
        if (refs == null) return;
        referenceMapper.deleteByVulnerabilityId(vm.getId());
        for (var r : refs) { if (r == null || r.getUrl() == null || r.getUrl().isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityMetadataReference e = new tech.cspioneer.backend.entity.VulnerabilityMetadataReference(); e.setVulnerabilityMetadataId(vm.getId()); e.setType(r.getType()); e.setUrl(r.getUrl()); referenceMapper.insert(e);}    }

    private void replaceCwe(VulnerabilityMetadata vm, List<String> ids, List<String> names) {
        if (ids == null && names == null) return;
        cweMapper.deleteByVulnerabilityId(vm.getId());
        int n = Math.max(ids == null ? 0 : ids.size(), names == null ? 0 : names.size());
        for (int i = 0; i < n; i++) {
            tech.cspioneer.backend.entity.VulnerabilityMetadataCwe e = new tech.cspioneer.backend.entity.VulnerabilityMetadataCwe();
            e.setVulnerabilityMetadataId(vm.getId());
            e.setCweId(ids != null && i < ids.size() ? ids.get(i) : null);
            e.setCweName(names != null && i < names.size() ? names.get(i) : null);
            cweMapper.insert(e);
        }
    }

    private void replaceTimeline(VulnerabilityMetadata vm, List<CosvUpsert.TimePoint> tps) {
        if (tps == null) return;
        timelineMapper.deleteByVulnerabilityId(vm.getId());
        for (var t : tps) { if (t == null || t.getType() == null || t.getValue() == null) continue; tech.cspioneer.backend.entity.VulnerabilityMetadataTimeline e = new tech.cspioneer.backend.entity.VulnerabilityMetadataTimeline(); e.setVulnerabilityMetadataId(vm.getId()); e.setType(t.getType()); e.setValue(parseRfc3339(t.getValue())); timelineMapper.insert(e);}    }

    private void replaceSeverities(VulnerabilityMetadata vm, List<CosvUpsert.SeverityItem> sevs) {
        if (sevs == null) return;
        severityMapper.deleteByVulnerabilityId(vm.getId());
        for (var s : sevs) { if (s == null) continue; tech.cspioneer.backend.entity.VulnerabilityMetadataSeverity e = new tech.cspioneer.backend.entity.VulnerabilityMetadataSeverity(); e.setVulnerabilityMetadataId(vm.getId()); e.setType(s.getType()); e.setScore(s.getScore()); e.setLevel(s.getLevel()); e.setScoreNum(s.getScoreNum()); severityMapper.insert(e);}    }

    private void replaceAffected(VulnerabilityMetadata vm, List<CosvUpsert.Affected> list) {
        if (list == null) return;
        // 删除旧 affected
        var pkgs = affectedPackageMapper.listByVulnerabilityId(vm.getId());
        for (var p : pkgs) { // delete child tables first
            var ranges = affectedRangeMapper.listByPackageId(p.getId());
            for (var r : ranges) { affectedRangeEventMapper.deleteByRangeId(r.getId()); }
            affectedRangeMapper.deleteByPackageId(p.getId());
            affectedVersionMapper.deleteByPackageId(p.getId());
            affectedCommitMapper.deleteByPackageId(p.getId());
        }
        affectedPackageMapper.deleteByVulnerabilityId(vm.getId());

        // 写入新 affected
        for (var a : list) {
            if (a == null || a.getPkg() == null) continue;
            var ps = a.getPkg();
            tech.cspioneer.backend.entity.VulnerabilityAffectedPackage pkg = new tech.cspioneer.backend.entity.VulnerabilityAffectedPackage();
            pkg.setVulnerabilityMetadataId(vm.getId());
            pkg.setEcosystem(ps.getEcosystem()); pkg.setName(ps.getName()); pkg.setPurl(ps.getPurl()); pkg.setLanguage(ps.getLanguage()); pkg.setRepository(ps.getRepository()); pkg.setHomePage(ps.getHomePage()); pkg.setEdition(ps.getEdition());
            pkg.setEcosystemSpecific(stringifyJsonOrNull(ps.getEcosystemSpecific()));
            // 将 affected.severity 暂存在 package.database_specific.severity
            Map<String, Object> pkgDbSpec = new LinkedHashMap<>();
            if (ps.getDatabaseSpecific() != null) {
                Object val = parseJsonOrRaw(ps.getDatabaseSpecific());
                if (val instanceof Map<?,?> mm) { mm.forEach((k,v)-> pkgDbSpec.put(String.valueOf(k), v)); } else { pkgDbSpec.put("_raw", ps.getDatabaseSpecific()); }
            }
            if (a.getSeverity() != null) pkgDbSpec.put("severity", a.getSeverity());
            pkg.setDatabaseSpecific(stringifyJsonOrNull(pkgDbSpec.isEmpty() ? null : pkgDbSpec));
            affectedPackageMapper.insert(pkg);

            // commits
            if (ps.getIntroducedCommits() != null) for (String c : ps.getIntroducedCommits()) { if (c == null || c.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityAffectedCommit ec = new tech.cspioneer.backend.entity.VulnerabilityAffectedCommit(); ec.setPackageId(pkg.getId()); ec.setCommitType("INTRODUCED"); ec.setCommitId(c); affectedCommitMapper.insert(ec);}            
            if (ps.getFixedCommits() != null) for (String c : ps.getFixedCommits()) { if (c == null || c.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityAffectedCommit ec = new tech.cspioneer.backend.entity.VulnerabilityAffectedCommit(); ec.setPackageId(pkg.getId()); ec.setCommitType("FIXED"); ec.setCommitId(c); affectedCommitMapper.insert(ec);}            

            // ranges
            if (a.getRanges() != null) for (var r : a.getRanges()) {
                tech.cspioneer.backend.entity.VulnerabilityAffectedRange er = new tech.cspioneer.backend.entity.VulnerabilityAffectedRange();
                er.setPackageId(pkg.getId()); er.setType(r.getType()); er.setRepo(r.getRepo()); er.setDatabaseSpecific(stringifyJsonOrNull(r.getDatabaseSpecific()));
                affectedRangeMapper.insert(er);
                if (r.getEvents() != null) for (var ev : r.getEvents()) {
                    if (ev == null || ev.isEmpty() || ev.size() != 1) throw new ApiException(400, "ranges.events 元素必须为单键对象");
                    Map.Entry<String, String> e = ev.entrySet().iterator().next();
                    tech.cspioneer.backend.entity.VulnerabilityAffectedRangeEvent ee = new tech.cspioneer.backend.entity.VulnerabilityAffectedRangeEvent();
                    ee.setRangeId(er.getId()); ee.setEventType(e.getKey()); ee.setValue(e.getValue());
                    affectedRangeEventMapper.insert(ee);
                }
            }

            // versions
            if (a.getVersions() != null) for (String v : a.getVersions()) { if (v == null || v.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityAffectedVersion ev = new tech.cspioneer.backend.entity.VulnerabilityAffectedVersion(); ev.setPackageId(pkg.getId()); ev.setVersion(v); affectedVersionMapper.insert(ev);}            
        }
    }

    private void replacePatchDetails(VulnerabilityMetadata vm, List<CosvUpsert.PatchDetail> list) {
        if (list == null) return;
        var olds = patchDetailMapper.listByVulnerabilityId(vm.getId());
        for (var pd : olds) { patchBranchMapper.deleteByPatchDetailId(pd.getId()); patchTagMapper.deleteByPatchDetailId(pd.getId()); }
        patchDetailMapper.deleteByVulnerabilityId(vm.getId());
        for (var p : list) {
            tech.cspioneer.backend.entity.VulnerabilityPatchDetail e = new tech.cspioneer.backend.entity.VulnerabilityPatchDetail();
            e.setVulnerabilityMetadataId(vm.getId()); e.setPatchUrl(p.getPatchUrl()); e.setIssueUrl(p.getIssueUrl()); e.setMainLanguage(p.getMainLanguage()); e.setAuthor(p.getAuthor()); e.setCommitter(p.getCommitter());
            patchDetailMapper.insert(e);
            if (p.getBranches() != null) for (String b : p.getBranches()) { if (b == null || b.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityPatchBranch br = new tech.cspioneer.backend.entity.VulnerabilityPatchBranch(); br.setPatchDetailId(e.getId()); br.setName(b); patchBranchMapper.insert(br);}            
            if (p.getTags() != null) for (String t : p.getTags()) { if (t == null || t.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityPatchTag tg = new tech.cspioneer.backend.entity.VulnerabilityPatchTag(); tg.setPatchDetailId(e.getId()); tg.setName(t); patchTagMapper.insert(tg);}            
        }
    }

    private void replaceContributors(VulnerabilityMetadata vm, List<CosvUpsert.Contributor> list) {
        if (list == null) return;
        contributorMapper.deleteByVulnerabilityId(vm.getId());
        for (var c : list) { tech.cspioneer.backend.entity.VulnerabilityContributor e = new tech.cspioneer.backend.entity.VulnerabilityContributor(); e.setVulnerabilityMetadataId(vm.getId()); e.setOrg(c.getOrg()); e.setName(c.getName()); e.setEmail(c.getEmail()); e.setContributions(c.getContributions()); contributorMapper.insert(e);}    }

    private void replaceCredits(VulnerabilityMetadata vm, List<CosvUpsert.Credit> list) {
        if (list == null) return;
        var olds = creditMapper.listByVulnerabilityId(vm.getId());
        for (var cr : olds) { creditContactMapper.deleteByCreditId(cr.getId()); }
        creditMapper.deleteByVulnerabilityId(vm.getId());
        for (var c : list) { tech.cspioneer.backend.entity.VulnerabilityCredit e = new tech.cspioneer.backend.entity.VulnerabilityCredit(); e.setVulnerabilityMetadataId(vm.getId()); e.setName(c.getName()); e.setType(c.getType()); creditMapper.insert(e); if (c.getContact() != null) for (String ct : c.getContact()) { if (ct == null || ct.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityCreditContact cc = new tech.cspioneer.backend.entity.VulnerabilityCreditContact(); cc.setCreditId(e.getId()); cc.setContact(ct); creditContactMapper.insert(cc);} }
    }

    private void replaceExploitStatus(VulnerabilityMetadata vm, List<String> list) {
        if (list == null) return;
        exploitStatusMapper.deleteByVulnerabilityId(vm.getId());
        for (String s : list) { if (s == null || s.isBlank()) continue; tech.cspioneer.backend.entity.VulnerabilityExploitStatus e = new tech.cspioneer.backend.entity.VulnerabilityExploitStatus(); e.setVulnerabilityMetadataId(vm.getId()); e.setStatus(s); exploitStatusMapper.insert(e);}    }

    private Float aggregateSeverityNum(List<CosvUpsert.SeverityItem> sevs, Float fallback) {
        if (sevs == null || sevs.isEmpty()) return fallback;
        Float max = null;
        for (var s : sevs) { if (s == null) continue; if (s.getScoreNum() != null) { if (max == null || s.getScoreNum() > max) max = s.getScoreNum(); } }
        return max != null ? max : fallback;
    }

    private LocalDateTime parseRfc3339(String s) {
        if (s == null || s.isBlank()) return null;
        try {
            return OffsetDateTime.parse(s).toLocalDateTime();
        } catch (DateTimeParseException e) {
            // 兜底尝试不带Z
            return LocalDateTime.parse(s);
        }
    }
    private LocalDateTime parseRfc3339Nullable(String s) { try { return parseRfc3339(s);} catch (Exception ex) { if (s == null || s.isBlank()) return null; throw new ApiException(400, "时间格式错误: " + s); } }
    private String toRfc3339(LocalDateTime dt) { if (dt == null) return null; return dt.atOffset(ZoneOffset.UTC).toString(); }
    private Object parseJsonOrRaw(Object jsonOrObj) {
        if (jsonOrObj == null) return null;
        if (jsonOrObj instanceof String s) {
            try { return objectMapper.readValue(s, Object.class);} catch (Exception e) { return s; }
        }
        // already structured object (e.g., Map) — return as-is
        return jsonOrObj;
    }
    private String stringifyJsonOrNull(Object o) { if (o == null) return null; try { return objectMapper.writeValueAsString(o);} catch (JsonProcessingException e) { throw new ApiException(400, "JSON序列化失败"); } }

    @Transactional
    public void addTag(String userUuid, String vulnUuid, String tagKey) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        ensureCanEdit(user, vm);
        if (tagKey == null || tagKey.trim().isBlank()) throw new ApiException(400, "标签不能为空");
        String nm = tagKey.trim();
        Tag t = tagMapper.findByCode(nm);
        if (t == null) t = tagMapper.findByName(nm);
        if (t == null) throw new ApiException(400, "标签不存在: " + nm);
        linkTagMapper.link(vm.getId(), t.getId());
        if (esIndexer != null) safeIndex(vm.getUuid());
    }

    @Transactional
    public void removeTag(String userUuid, String vulnUuid, String tagKey) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        ensureCanEdit(user, vm);
        Tag t = null;
        if (tagKey != null) {
            String nm = tagKey.trim();
            if (!nm.isBlank()) {
                t = tagMapper.findByCode(nm);
                if (t == null) t = tagMapper.findByName(nm);
            }
        }
        if (t != null) linkTagMapper.unlink(vm.getId(), t.getId());
        if (esIndexer != null) safeIndex(vm.getUuid());
    }

    @Transactional
    public VulnerabilityProject addProject(String userUuid, String vulnUuid, VulnerabilityProject p) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        ensureCanEdit(user, vm);
        p.setUuid(UUID.randomUUID().toString());
        p.setVulnerabilityMetadataId(vm.getId());
        if (p.getType() == null || p.getType().isBlank()) p.setType("AFFECTED");
        projectMapper.insert(p);
        return projectMapper.findByUuid(p.getUuid());
    }

    private void safeIndex(String uuid) {
        try { esIndexer.indexOne(uuid); } catch (Exception ignore) {}
    }

    @Transactional
    public void deleteOwned(String userUuid, String vulnUuid) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        boolean allowed = false;
        if (vm.getUserId() != null && vm.getUserId().equals(user.getId())) {
            allowed = true;
        } else if (vm.getOrganizationId() != null) {
            LnkUserOrganization link = lnkUserOrgMapper.findByOrgIdAndUserId(vm.getOrganizationId(), user.getId());
            if (link != null && link.getRole() == tech.cspioneer.backend.enums.OrganizationRole.ADMIN) {
                allowed = true;
            }
        }
        if (!allowed) throw new tech.cspioneer.backend.common.ApiException(1012, "权限不足");

        // 软删除：置状态为 DELETED
        vmMapper.updateStatusReviewByUuid(vulnUuid, tech.cspioneer.backend.enums.VulnerabilityStatus.DELETED.getCode(), null, false, null, null);
        // ES 删除
        if (esIndexer != null) {
            try { esIndexer.deleteOne(vulnUuid); } catch (Exception ignore) {}
        }
    }

    @Transactional
    public void removeProject(String userUuid, String vulnUuid, String projectUuid) {
        User user = requireUserByUuid(userUuid);
        VulnerabilityMetadata vm = getByUuid(vulnUuid);
        ensureCanEdit(user, vm);
        VulnerabilityProject proj = projectMapper.findByUuid(projectUuid);
        if (proj == null || !proj.getVulnerabilityMetadataId().equals(vm.getId())) {
            throw new ApiException(404, "项目不存在");
        }
        projectMapper.deleteByUuid(projectUuid);
    }

    private String generateIdentifier() {
        CosvGeneratedId gid = new CosvGeneratedId();
        idMapper.insert(gid);
        long seq = gid.getId() == null ? 0 : gid.getId();
        String year = String.valueOf(Year.now().getValue());
        return String.format("COSV-%s-%06d", year, seq);
    }

    private User requireUserByUuid(String uuid) {
        User u = userMapper.findByUuid(uuid);
        if (u == null || u.getStatus() == null) throw new ApiException(1005, "用户状态异常");
        return u;
    }

    private void ensureMember(Long orgId, Long userId) {
        if (lnkUserOrgMapper.findByOrgIdAndUserId(orgId, userId) == null) throw new ApiException(1012, "权限不足");
    }

    private void ensureCanEdit(User user, VulnerabilityMetadata vm) {
        var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getDetails() instanceof tech.cspioneer.backend.security.ApiKeyContext ctx) {
            if ("ORG".equalsIgnoreCase(ctx.getSubjectType())) {
                if (ctx.getOrgUuid() != null && vm.getOrganizationId() != null) {
                    Organization org = organizationMapper.findByUuid(ctx.getOrgUuid());
                    if (org != null && !org.getId().equals(vm.getOrganizationId())) {
                        throw new ApiException(1012, "组织Key无权编辑其他组织漏洞");
                    }
                } else if (vm.getOrganizationId() == null) {
                    // 组织 Key 不得编辑个人漏洞
                    throw new ApiException(1012, "组织Key无权编辑个人漏洞");
                }
            } else if ("USER".equalsIgnoreCase(ctx.getSubjectType())) {
                // 个人 Key 不得编辑组织漏洞
                if (vm.getOrganizationId() != null) {
                    throw new ApiException(1012, "个人Key无权编辑组织漏洞");
                }
            }
        }
        if (isAdmin()) return;
        if (vm.getUserId() != null && vm.getUserId().equals(user.getId())) return;
        if (vm.getOrganizationId() != null) {
            LnkUserOrganization link = lnkUserOrgMapper.findByOrgIdAndUserId(vm.getOrganizationId(), user.getId());
            if (link != null && link.getRole() == tech.cspioneer.backend.enums.OrganizationRole.ADMIN) return;
        }
        throw new ApiException(1012, "权限不足");
    }

    private String emptyToNull(String s) { return (s == null || s.isBlank()) ? null : s; }
    private boolean hasLevel(String csv, String lvl) { if (csv == null) return false; for (String p : csv.split(",")) { if (lvl.equalsIgnoreCase(p.trim())) return true; } return false; }
    private String normalizeCSV(String csv) { if (csv == null) return null; StringBuilder b = new StringBuilder(); for (String p : csv.split(",")) { String t = p == null ? null : p.trim(); if (t == null || t.isEmpty()) continue; if (b.length()>0) b.append(","); b.append(t.toUpperCase(java.util.Locale.ROOT)); } return b.toString(); }

    private boolean isAdmin() {
        var auth = org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || auth.getAuthorities() == null) return false;
        for (var a : auth.getAuthorities()) {
            if ("ROLE_ADMIN".equals(a.getAuthority())) return true;
        }
        return false;
    }
}
